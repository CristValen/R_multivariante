---
title: "PEC1"
author: "Cristopher Valenzuela"
date: "10 de noviembre de 2021"
output:
  html_document:
    df_print: paged
  pdf_document: default
---

Las enfermedades del análisis fueron Norovirus, Salmonella spp, Escherichia coli, Campylobacter spp,
Shigella spp, Clostridium spp, Staphylococcus spp, Yersinia spp, Bacillus spp, otros virus y otros microorganismos.
Las verduras eran Ensalada (todos los productos relacionados con la ensalada), Hojas (todos
los productos relacionados con las hojas), Tomate y Otras verduras. Las frutas fueron Germinados (todos
los productos relacionados con los germinados), Bayas, Melón, Zumos y Otras frutas.
Los datos se encuentran en el archivo vegetables.zip. Aunque se pueden cargar desde el archivo
vegetables.mat de Matlab, se recomienda leerlos desde los otros archivos. El archivo vegetables.dat
contiene tres columnas de datos. La primera columna es la variable illness (enfermedad), la segunda es
la variable veg.fruit (verduras/frutas). Y, por último, la tercera columna es la variable region (región).
Los nombres de todos los elementos que necesitamos se hallan en el archivo vegetables_labels.txt de
forma ordenada según la codificación.

(a) Obtener las tablas de contingencia entre enfermedades y verduras-frutas separadas por región.

```{r}

library(readr)
vegetables <- read_table2("C:/Users/Cristopher/Desktop/certificados/UOC/Bioestadistica y Bioinformatica/Analisis Multivariante/PEC1/vegetables.dat", 
    col_names = FALSE)

vegetables_labels <- read_table2("C:/Users/Cristopher/Desktop/certificados/UOC/Bioestadistica y Bioinformatica/Analisis Multivariante/PEC1/vegetables_labels.txt", 
    col_names = FALSE)

lista_vegetables<-as.data.frame(vegetables)


#lista_vegetables<-matrix(lista_vegetables,ncol = 3)

#tabla_vegetables <- matrix(lista_vegetables, ncol=3)


vegetables_eu<-lista_vegetables[1:197,]


vegetables_usa<-lista_vegetables[198:561,]
vegetables_usa$X1 = factor(vegetables_usa$X1,levels = c(1:11))

tabla_eu<-table(vegetables_eu)
tabla_usa<-table(vegetables_usa)


#agregamos las etiquetas para EU
rownames(tabla_eu)<-c("Norovirus","Salmonella","E-coli","Campylobacter","Shigella"
,"Clostridium","Staphylococcus","Yersinia","Bacillus","Other-viruses","Other-microorganisms")

colnames(tabla_eu)<-c("Salad","Leafy","Tomato","Other-vegetables","Sprouts","Berries","Melon","Juices","Other-fruits")



#agregamos la etiqueta para USA
rownames(tabla_usa)<-c("Norovirus","Salmonella","E-coli","Campylobacter","Shigella"
,"Clostridium","Staphylococcus","Yersinia","Bacillus","Other-viruses","Other-microorganisms")

colnames(tabla_usa)<-c("Salad","Leafy","Tomato","Other-vegetables","Sprouts","Berries","Melon","Juices","Other-fruits")


#finalmente obtenemos las tablas que necesitamos
tabla_eu
tabla_usa



```



(b) Realizar un análisis de correspondencias de las tablas, representar los resultados y comentarlos
brevemente.
Nota: Es posible que con alguna de las tablas tengamos dificultades que hay que resolver de forma
expeditiva.

```{r setup, include=FALSE}

library(gplots)
#convertimos en array los datos
table_eu2<-as.data.frame.array(tabla_eu)
dt <- as.table(as.matrix(table_eu2))
balloonplot(t(dt), main ="Tabla datos ", xlab ="", ylab="",
            label = FALSE, show.margins = FALSE)



```

En este caso s epuede observar que las principalmente encontramos relacionada el norovirus con berries, en menor medida con "salad" y "leafy"

```{r}

chisq <- chisq.test(dt)
chisq

```

En este caso vemos que las variables estan asociadas estadisticamente significativas, cuyo p-value es de 7.245e-14.


```{r}

library(FactoMineR)
datos.ca <- CA(table_eu2, graph = FALSE)
plot.CA(datos.ca)

```


```{r}

library("FactoMineR")
res.ca <- CA(dt, graph = FALSE)
res.ca
```


```{r}

library("factoextra")
eig.val <- get_eigenvalue(res.ca)
eig.val

fviz_screeplot(res.ca, addlabels = TRUE, ylim = c(0, 50))

```


Observamos que los dos primeros dimensiones representan el 86.1 de la varianza,



```{r}

fviz_ca_biplot(res.ca, repel = TRUE)
fviz_ca_biplot(res.ca, 
               map ="rowprincipal", arrow = c(TRUE, TRUE),
               repel = TRUE)
```



Ahora hacemos lo mismo para la tabla de USA

```{r}

library(gplots)
#convertimos en array los datos
table_usa2<-as.data.frame.array(tabla_usa)
du <- as.table(as.matrix(table_usa2))
balloonplot(t(du), main ="Tabla datos USA", xlab ="", ylab="",
            label = FALSE, show.margins = FALSE)

```

Observamos que la enfermedad de norovirus se encuentra relacionada principalmente con "salad" y "leafy" principalmente, en la region de USA. 


```{r}

chisq2 <- chisq.test(du)
chisq2

```


```{r}
library(FactoMineR)
datos.usac <- CA(table_usa2, graph = FALSE)
plot.CA(datos.usac)
```



```{r}


library("FactoMineR")
res.ca2 <- CA(du, graph = FALSE)
res.ca2

```


```{r}


library("factoextra")
eig.val <- get_eigenvalue(res.ca2)
eig.val

fviz_screeplot(res.ca2, addlabels = TRUE, ylim = c(0, 50))

```


En este caso la primera dimension reprsenta un poco mas del 50%, y con la segun explica pcoo mas del 70%.


```{r}



fviz_ca_biplot(res.ca2, repel = TRUE)
fviz_ca_biplot(res.ca2, 
               map ="rowprincipal", arrow = c(TRUE, TRUE),
               repel = TRUE)



```



(a) Utilizar las disimilaridades del archivo monk_84.dis2 para definir un objeto del tipo dist en R o una
matriz simétrica con esas disimilaridades. Observaremos el orden de la tabla 1 que se puede obtener
del archivo monkeys.dat. El vector con las 91 disimilaridades debe rellenar la matriz triangular inferior del objeto por columnas. También habrá que poner nombres a las filas y columnas de la
matriz.
Lo mismo para el archivo monk_85.dis con las disimilaridades en la temporada de cría.

```{r}

library(matlib)
library(readr)
monk_84 <- read_csv("C:/Users/Cristopher/Desktop/certificados/UOC/Bioestadistica y Bioinformatica/Analisis Multivariante/PEC1/monk_84.dis", 
    col_names = FALSE)
#eliminamos las filas que no necesitamos
monk_84 = monk_84[-1:-2,]
monk_84 = monk_84[-92:-105,]
View(monk_84)

monk_85 <- read_csv("C:/Users/Cristopher/Desktop/certificados/UOC/Bioestadistica y Bioinformatica/Analisis Multivariante/PEC1/monk_85.dis", 
    col_names = FALSE)
monk_85 = monk_85[-1:-2,]
monk_85 = monk_85[-92:-105,]
View(monk_85)

#ahora creamos la matriz 


matriz1<-symMat(monk_84$X1, diag = FALSE, byrow =TRUE, names = TRUE)
matriz2<-symMat(monk_85$X1,diag = FALSE,byrow = TRUE,names = TRUE)


rownames(matriz1) <- c("ALFA","FRAN","FELL","PANC","ISA","GILD","BETI","OLGA","ORSE","ROSS","DIVO","CIST","ELET","EVA")


matriz1<-as.dist(matriz1)

rownames(matriz2) <- c("ALFA","FRAN","FELL","PANC","ISA","GILD","BETI","OLGA","ORSE","ROSS","DIVO","CIST","ELET","EVA")
matriz2<-as.dist(matriz2)

matriz1 
matriz2

```


(b) Comprobar que las disimilaridades en las dos temporadas forman conjuntos no euclídeos. ¿Qué
significa esto?
Nota: Solucionar cualquier error en el procedimiento con la substitución de un valor por otro válido
si es necesario.

```{r}

#podemos comprobar si es son conjuntos 
library(ade4)
#como tenemos un error porque en nuestra matriz hay ceros, debemos cambiar dicho numeros, existan varias maneras de hacerlo, pero una de ella seria reemplazar los ceros por el valor mas proximo que sea valida, en este caso podria ser reemplazados por un 1 o por 1/5 del valor minimo de a matriz, en este caso el minimo es 2, por lo tanto lo reemplazamos los 0 por un 2/5.

monk_85b = monk_85[-1:-2,]
monk_85b = monk_85[-92:-105,]
monk_85b = as.numeric(monk_85b$X1)

monk_85b[70] <- 0.4
monk_85b[82] <- 0.4

matriz2b<-symMat(monk_85b, diag = FALSE, byrow =TRUE, names = TRUE)

is.euclid(as.dist(matriz2b),print=T)

```

En este caso obtenemos que el conjunto no es euclideo, ya que hay valores propios que son negativos

```{r}

#realizamos lo mismo para la otra matriz, aqui el minimo es 1 asi que reemplazamos el 0 por el 1/5.
monk_84b = monk_84[-1:-2,]
monk_84b = monk_84[-92:-105,]
monk_84b = as.numeric(monk_84b$X1)

monk_84b[54] <- 0.2
monk_84b[82] <- 0.2

matriz1b<-symMat(monk_84b, diag = FALSE, byrow =TRUE, names = TRUE)

is.euclid(as.dist(matriz1b),print=T)


```

En este caso obtenemos que el conjunto no es euclideo, ya que hay valores propios que son negativos.

(c) Realizar el MDS más apropiado (clásico, métrico o no métrico) con las disimilaridades de las dos
temporadas por separado.
¿Cual es el stress en cada caso? Expresarlos en tanto por ciento.


```{r}

set.seed(123)
library(MASS)
library(vegan)
data.dist1 <- vegdist(matriz1, "bray")
nmds.iso1 <- isoMDS(data.dist1, trace = FALSE)
nmds.iso1
 
```


```{r}
matriz1<-symMat(monk_84$X1, diag = FALSE, byrow =TRUE, names = TRUE)

rownames(matriz1) <- c("ALFA","FRAN","FELL","PANC","ISA","GILD","BETI","OLGA","ORSE","ROSS","DIVO","CIST","ELET","EVA")


plot(nmds.iso1$points[,1], nmds.iso1$points[,2], type = "n",
 xlab="NMDS1", ylab="NMDS2")
text(nmds.iso1$points[,1], nmds.iso1$points[,2], labels = rownames(matriz1), cex=0.8)


```


```{r}
set.seed(123)
nmds.meta1 <- metaMDS(matriz1, distance="bray",engine = "monoMDS")
nmds.meta1$stress*100

```


El estres en este caso es del 25% lo que se consideraria alto.

```{r}

plot(nmds.meta1, type="text")


```

En este caso vemos que la segun forma es la mejor, los niveles de estress tienden a aumentar de igual manera, y es mayor en este segundo caso que con los primeros resultados obtenidos.

Ahora aplicamos lo mismo para la segunda matriz


```{r}

set.seed(123)
library(MASS)
library(vegan)
data.dist2 <- vegdist(matriz2, "bray")
nmds.iso2 <- isoMDS(data.dist2, trace = FALSE)
nmds.iso2

```


```{r}

matriz2<-symMat(monk_85$X1, diag = FALSE, byrow =TRUE, names = TRUE)

rownames(matriz2) <- c("ALFA","FRAN","FELL","PANC","ISA","GILD","BETI","OLGA","ORSE","ROSS","DIVO","CIST","ELET","EVA")


plot(nmds.iso2$points[,1], nmds.iso2$points[,2], type = "n",
 xlab="NMDS1", ylab="NMDS2")
text(nmds.iso2$points[,1], nmds.iso2$points[,2], labels = rownames(matriz2), cex=0.8)

```


```{r}

set.seed(123)
nmds.meta2 <- metaMDS(matriz2, distance="bray",engine = "monoMDS")
nmds.meta2$stress*100

```


El estres es del 25%, ademas vemos que con este metodo tiende a aumentar al 25%.


```{r}

plot(nmds.meta2, type="text")

```


Tambien obtenemos que la mejor manera seria esta ultima, el stress aumenta a un 25%, lo cual se consideraria alto para este caso.

(d) Dibujar la representación de puntos con las mejores soluciones del apartado anterior, una para cada
temporada.
Poner distintos colores a machos y hembras. Interpretar el resultado.


```{r}

monkeys<-read_csv("C:/Users/Cristopher/Desktop/certificados/UOC/Bioestadistica y Bioinformatica/Analisis Multivariante/PEC1/PEC1_multivariante/monkeys.csv", 
    col_names = FALSE)

library(readr)
monkeys <- read_csv("monkeys.csv")
#View(monkeys)


#graficamos para la epoca fuera de la cria
library(tidyverse)
library(ggrepel)
plot.nmds1<-as.data.frame(nmds.meta1$points)

plot.nmds1$sex = as.factor(monkeys$sex)

p1 <- ggplot(plot.nmds1, aes(plot.nmds1$MDS1, plot.nmds1$MDS2)) +
  geom_point(color = 'red') +
  theme_classic(base_size = 10)

p1 + geom_label_repel(aes(label = rownames(plot.nmds1),
                    fill = factor(plot.nmds1$sex)), color = 'white',
                    size = 3.5) +
   theme(legend.position = "bottom")
 



```


Ahora, realizamos un plot para la segunda temporada

```{r}


#graficamos para la temporada de la cria
library(tidyverse)
library(ggrepel)
plot.nmds2<-as.data.frame(nmds.meta2$points)

plot.nmds2$sex = monkeys$sex

p2 <- ggplot(plot.nmds2, aes(plot.nmds2$MDS1, plot.nmds2$MDS2)) +
  geom_point(color = 'red') +
  theme_classic(base_size = 10)

p2 + geom_label_repel(aes(label = rownames(plot.nmds2),
                    fill = factor(plot.nmds2$sex)), color = 'white',
                    size = 3.5) +
   theme(legend.position = "bottom")


```


Despues de observar los graficos, podemos apreciar que para el periodo de cria y no de cria el estress fue del 25% con el mejor metodo, esto podria indicar un mal ajuste. Vemos que para la temporada de "reproduccion" los machos alfa,divo,cist, beti, se acercan mas entre si, mientras que para las "female" tienden a alejarse en de los demas en la epoca de cria.


(e) Comparar las dos configuraciones de las temporadas con la función procrustes().
¿Cual es el mono con menor residuo entre las dos configuraciones?


```{r}

library(vegan)

proce <- procrustes(nmds.meta1,nmds.meta2)
plot(proce)


```


```{r}


proce$X

```


os monos como feel,eva y orse, tienden a mantener algunas posiciones relativas, pero muchos de monos no la mantienen, se ven distancia entre la una y otra temporada.

(f) Como el stress es alto, podemos optar por una representación en tres dimensiones. Hacer la representación de la temporada de cría con la ayuda de la función plot_ly(). Representar en dos colores
machos y hembras. ¿Qué observamos?

```{r}

library(plotly)

set.seed(123)
nmds.meta2 <- metaMDS(matriz2, distance="bray",engine = "monoMDS")
nmds.meta2$stress*100
plot.nmdsf = plot.nmds2
plot.nmdsf$mns3 = plot.nmds2$MDS1
plot.nmdsf$sex = factor(plot.nmdsf$sex)

plot_ly(x = plot.nmdsf$MDS1, y = plot.nmdsf$MDS2, z = nmds.meta2$stress*100,
        color = plot.nmdsf$sex)




```


Observamos que los machos tienden a estar cerca y agruparse, sin embargo hay uno que se aleja de los demas, estos ademas estan mas cerca del nivel de estress maximo.

Ejercicio 3

(a) El primer vector propio da las cargas (loadings) de cada variable en la primera componente principal,
el segundo vector propio da las cargas en la segunda componente y así sucesivamente. Comprobar
este resultado con la función princomp().


```{r}
#cargamos los datos
load("C:/Users/Cristopher/Desktop/certificados/UOC/Bioestadistica y Bioinformatica/Analisis Multivariante/2. Analisis de componentes principales/gorriones.RData")

head(gorriones)

```



```{r}

gorrionesa<- gorriones[,-6]
gorrionesa<-scale(gorrionesa)
head(gorrionesa)

```


```{r}

gorrionesa_pca <- princomp(x = gorrionesa,cor = TRUE)
gorrionesa_pca
```

```{r}

print(summary(gorrionesa_pca), loadings = TRUE)

```

```{r}

gorrionesa_pca$loadings[,1:5]
gorrionesa_pca$loadings

```


```{r}
#calculamos los vectores propios

(vectores_propios = eigen(cor(gorrionesa))$vectors)       # Using eigen() method
(vectores_propios.svd = svd(gorrionesa)$v)         

#cargamos las cargas obtenidas anteriormente con princomp()

gorrionesa_pca$loadings[,1:5]

```

(b) Escribiendo las cargas de las primeras q componentes como columnas de la matriz p×q B, la matriz
n × q P de las puntuaciones (scores) de las componentes principales de los individuos se obtiene
aplicando las cargas a la matriz de datos original, es decir, P = XB.

```{r}

# SCORES por multiplicacion de matrices

scores = gorrionesa %*% gorrionesa_pca$loadings[,1:5] 
head(scores)  
  
```

multiplicamos la carga por la matriz original

```{r}

head(gorrionesa_pca$scores)

```


c) La matriz de suma de cuadrados y productos, P'P = D, es diagonal con elementos iguales a los
primeros q valores propios de de la matriz X'X, de modo que las varianzas de las componentes
principales pueden obtenerse dividiendo los valores propios por n o n − 1.


```{r}

#calculamos la P'P 
Dc = t(scores) %*% scores
#obtenemos las varianzas de os componentes principales dividiendo por n
diag(Dc)/length(gorrionesa)


```

En este caso obtenemos la misma proporcion de la varianza de los componentes calculados en un apartado anterior, para los componentes uno, dos , tres , cuatro y cinco respectivamente


(d) El primer punto consiste en substituir los valores desconocidos (missings) de la matriz X (la de los
controles) por la media de cada columna.
El siguiente es estandarizar los datos para que tengan media cero y desviación estándar uno y
finalmente calcular la matriz XX.

```{r}

load("C:/Users/Cristopher/Desktop/certificados/UOC/Bioestadistica y Bioinformatica/Analisis Multivariante/PEC1/SNP.RData")
controls <- rownames(subject.support)[subject.support$cc==0]
pop <- subject.support[controls,"stratum"]
pop.all <- subject.support[,"stratum"]
use <- seq(1, ncol(snps.10), 10)
ctl10 <- snps.10[controls, use]
all10 <- snps.10[,use]
X <- as(ctl10, "numeric")
X.all <- as(all10,"numeric")


# 1 opcion

data <- X
  
for(i in 1:ncol(data)){
  data[is.na(data[,i]), i] <- mean(data[,i], na.rm = TRUE)
}



x.escalado<-scale(data)
#head(x.escalado)

# finalmente calculamos la XX'

xxtrasposicion<-x.escalado %*% t(x.escalado)
head(xxtrasposicion[1:6,1:6])

```


(e) Calcular los valores y vectores propios de la matriz XX y, a partir de ellos, la matriz U.
Comparar gráficamente las puntuaciones de la primera componente para los controles según la
población.
Hacer el mismo gráfico con la segunda y tercera componentes. ¿Qué componente separa mejor las
poblaciones?
Nota1 : En todos estos apartados procuraremos minimizar el tiempo de cálculo. Para ello utilizaremos
las funciones de R que optimizan los productos de ciertas matrices o mejoran la obtención de
los valores y vectores propios de algunas matrices.
Nota2 : Como se ha dicho anteriormente, tomaremos como matriz de puntuaciones U directamente
de los vectores propios de XX0 en lugar de P.


```{r}


#calculamos los valores propios y vectores propios

vectores.valores<-eigen(xxtrasposicion)
head(vectores.valores$values)
head(vectores.valores$vectors[1:9,1:9])

 par(mfrow=c(2,4))
 boxplot(vectores.valores$vectors[,1]~pop)
 boxplot(vectores.valores$vectors[,2]~pop)

boxplot(vectores.valores$vectors[,2]~pop)
 boxplot(vectores.valores$vectors[,3]~pop)

```



Observando los graficos, vemos que solo en el primer componente vemos una diferencia entre las poblaciones.


(f) Calcular las cargas B según se ha explicado antes.
Nota: Es posible que debamos corregir algún valor entre los valores propios obtenidos.

```{r}

#El ultimo numero es negativo, pero lo podriamos considerar 0, asi que lo cambiamos por un cero

vectores.valores$values[500]<-0


cargas.f =  diag(1/sqrt(vectores.valores$values)) %*% t(vectores.valores$vectors)

head(cargas.f[1:9,1:9])

```



(g) Calcular las puntuaciones de las dos primeras componentes de todas las observaciones con las cargas
de los controles.
Representarlas en un gráfico de dispersión con dos colores según la población. ¿Qué podemos destacar?
Nota: Para ello habrá que proceder primero como en el apartado (d) pero con la matriz X.all.

```{r}

library(tidyverse)

datag <- X.all
  
for(i in 1:ncol(datag)){
  datag[is.na(datag[,i]), i] <- mean(datag[,i], na.rm = TRUE)
}

escaladog<-scale(datag)
#head(x.escalado)
ftrasposicion<- escaladog %*% t(escaladog)
vectores.valoresf<-eigen(ftrasposicion)

fcomponent<-prcomp(ftrasposicion)
plot(fcomponent$x)

```

